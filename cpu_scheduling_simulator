#include <stdio.h>
#include <stdlib.h>
#define LINE_MAX 1024

int prem=0;
struct node
{
    int burst_Time, arrival_Time, priority, pc;
    struct node *next;

};
struct node *head;

struct node *createNode_insert(int burst_Time,int arrival_Time,int priority,int p){
	struct node * tmp;
	tmp=(struct node *) malloc (sizeof (struct node));
	tmp->burst_Time=burst_Time;
	tmp->arrival_Time=arrival_Time;
	tmp->priority=priority;
	tmp->pc=p;
	tmp->next= NULL;
return tmp;
	
}
struct node *Back(struct node *head, int burstTime, int arrivalTime, int priority, int cn)
{
    struct node *tmp = createNode_insert(burstTime, arrivalTime, priority, cn);
    struct node *data;
    if (head == NULL)
    {
        head = tmp;
        return head;
    }
    data = head;
    while (data->next != NULL)
        data = data->next;
    data->next = tmp;
    return head;
}

struct node  *readFile (void);
void simulation(void);
void scheduling(void);
void Arrival_sort(struct node * head);
void swap(struct node *,struct node *);
void Job_sort(struct node *head); 
int Nodes_count(struct node *head);
void FCFS(void);
void SJFSNP(void);
void SJFSP(void);
int main(int argc,char **argv){                                       
	
 readFile();	
 simulation();

return 0;
}


struct node *readFile(){
	
	FILE *fp;
char line[LINE_MAX];
 int num[3];
int processcount;

	if ((fp = fopen("input.txt", "r")) == NULL){
	printf("error opening the input file \n");
        return 0;
        }
	while (fgets(line, LINE_MAX, fp) != NULL) {
	processcount++;
        sscanf(line,"%d:%d:%d\n",&num[0],&num[1],&num[2]);
       head=Back(head,num[0],num[1],num[2],processcount);     
}

	fclose(fp);

    return head;
}
void simulation(void){
	int choise;
	printf(" CPU scheduler simulator \n");
	printf("\n 1) secheduling method.");
	printf("\n 2) preemptive moode.");
	printf("\n 3) Non-preemptive mode.");
	printf("\n 4) show results for all methods.");
	printf("\n 5) End the program.");
   	printf("\n please enter your choise:");

	scanf("%d", &choise);


	if(choise==1){
	scheduling();
	}
	else if(choise==2){
	prem=1;
	simulation();
	}
	else if (choise==3){
	prem=0;
	simulation();
	}
	else if (choise==4){
	if(prem==0){	
 	SJFSNP();
 	FCFS();                    
	}
 
 	else if(prem==1){
 	FCFS();  	
 	}
	}
	else if (choise==5){
		printf("closing the program ....");
		exit (1);
		 	}
		else{
	printf("invalid input \n");
	simulation();
	}	

}

void scheduling(void){
	int choise;
	printf("\nscheduling Methods\n");
	printf("\n 1) First-come,first-served.");
   	printf("\n 2) Shortest-Job-first scheduling.");
 
	scanf("%d",&choise);
	if(choise==1){
	
		FCFS();
	}
	else if(choise==2){
		if(prem==0)
	SJFSNP();
	else if (prem==1){
		SJFSP();
	}	
}
}

void FCFS(void){                                           
	printf("FIRST COME FIRST SERVED \n Process waiting Time:");
	
        int waitingTime=0,count=0,total_WaitingTime=0,pc=0;
        double averageWaiting=0;
        struct node *tmp=head;

      while(tmp!=NULL){ 
	    Arrival_sort(head);
		tmp=tmp->next;}
	    
	    tmp=head;
	    
	    while(tmp!=NULL){
	    	count++;
	    	waitingTime=waitingTime-tmp->arrival_Time;
	    	pc=tmp->pc;
		   	printf("\n p%d=%d ms",pc,waitingTime);
         	total_WaitingTime=total_WaitingTime+waitingTime;
		   	waitingTime=waitingTime+tmp->burst_Time+tmp->arrival_Time;
		   	
      	tmp=tmp->next; 
      	 }

			 averageWaiting=total_WaitingTime/count;
			printf("\n The Average Waiting Time = %.2f ms",averageWaiting);	   
	 simulation();	
	 }	
	
	void Arrival_sort(struct node *head){
    struct node *tempdata = head;
   
       
        while (tempdata->next != NULL)
        {
            if (tempdata->arrival_Time > tempdata->next->arrival_Time)
            {
                swap(tempdata, tempdata->next);
                
            }
           tempdata = tempdata->next;
        }
        head = tempdata;      	 
		
	}
	
	void swap(struct node *i, struct node *j){
	

	int temp_burstTime = i->burst_Time;
    	i->burst_Time = j->burst_Time;
    	j->burst_Time = temp_burstTime;

    int temp_arrivalTime = i->arrival_Time;
    i->arrival_Time = j->arrival_Time;
    j->arrival_Time = temp_arrivalTime;

    int temp_priority = i->priority;
    i->priority = j->priority;
    j->priority = temp_priority;

    int temp_pc = i->pc;
    i->pc = j->pc;
    j->pc = temp_pc;
}


void SJFSNP(void){
	printf(" Shortest-job, first-served Non-preemptive\n processes waiting time:");
	struct node *temp=head;
	struct node *tmp=temp;
    int counter=Nodes_count(temp);
    int n=0,i=0,j=0,burst[counter],arrival[counter],pc[counter], waiting=0,tmpburst=0,totalWaiting=0;
    
    while(temp!=NULL){
    Job_sort(tmp);
    temp=temp->next; 
		}
		
		temp=tmp;
    for(n;n<counter;n++){
    burst[n]=temp->burst_Time;
	arrival[n]=temp->arrival_Time;
	pc[n]=temp->pc;
	temp=temp->next;
    		}
 for(i;i<counter;i++){
for(j=0;j<counter;j++){
	if(waiting-arrival[j] >= 0 && burst[j] != 0){
		waiting=waiting-arrival[j];
		totalWaiting=totalWaiting+waiting;
		
		printf("\n p%d = %d ms",pc[j],waiting);

		waiting=waiting+burst[j]+arrival[j];
		burst[j]=0;
	}
}	
 }
double averagewaiting_Time=totalWaiting/(float)counter;
 printf("\n Average Waiting Time = %.2f ms",averagewaiting_Time);

 
 simulation();
       }

void Job_sort(struct node *head){
	
	 struct node *temp = head;
   
       
        while (temp->next != NULL)
        {
            if (temp->burst_Time > temp->next->burst_Time)
            {
                swap(temp, temp->next);
                
            }
           temp = temp->next;
        }
        head = temp;    
  
}

int Nodes_count(struct node *head){
	int counter=0;
	struct node *temp=head;
	while(temp!=NULL){
		counter++;
		temp=temp->next;
	}
	return counter;
}


void SJFSP(void){
	printf("Shortest-job, first-served preemptive\n processes waiting time:");	
	struct node *temp=head;
	struct node *tmp=temp;
    int counter=Nodes_count(temp);
    int n=0,i=0 , j=0,burst[counter],arrival[counter],pc[counter], waiting[counter],tmpburst=0,totalWaiting=0,wait=0,m=0,totalBurst=0,count[counter],a=0;
    
    while(temp!=NULL){
    Job_sort(tmp);
    temp=temp->next;
		}
		
		 for(m=0;m<counter;m++){
    	waiting[m]=0;
    	count[m]=0;	}
		
		temp=tmp;
    for(n;n<counter;n++){
    burst[n]=temp->burst_Time;
	arrival[n]=temp->arrival_Time;
	pc[n]=temp->pc;
	temp=temp->next;
    		}
    		
    		for(n=0;n<counter;n++){
    			totalBurst=totalBurst+burst[n];
			}
    		
for(i;i<totalBurst;i++){	

  for(j=0;j<counter;j++){
  	 
	if(wait-arrival[j] >= 0 && burst[j] != 0 ){
		
		for(m=0;m<counter;m++){
			for(n=m+1;n<counter;n++){
		if(burst[m] == burst[n] && arrival[m]>arrival[n]){
	int a=burst[m];
	burst[m]=burst[n];
	burst[n]=a;
	
	a=arrival[m];
	arrival[m]=arrival[n];
	arrival[n]=a;
	
	a=pc[m];
	pc[m]=pc[n];
	pc[n]=a;
	
	a=count[m];
	count[m]=count[n];
	count[n]=a;
	
	a=waiting[m];
	waiting[m]=waiting[n];
	waiting[n]=a;
		}	}}
			waiting[j]=wait-count[j];
			burst[j]--;
			count[j]++;
			wait++; 
		   j=counter-1;	}		
	
			   }
	}
for(j=0;j<counter;j++){
 	waiting[j]=waiting[j]-arrival[j];
 	printf("\np%d = %d ms",pc[j],waiting[j]);
	 totalWaiting=totalWaiting+waiting[j] ;
	 }
double averagewaiting_Time=totalWaiting/(float)counter;
 printf("\n Average Waiting Time = %.2f ms",averagewaiting_Time);
 
 simulation();
}
